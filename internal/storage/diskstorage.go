package storage

import (
	"bytes"
	"encoding/json"
	"io/ioutil"
	"os"
	"path"
	"strings"

	"github.com/sbrki/snote/internal/util"
)

type DiskStorage struct {
	path string
}

func NewDiskStorage(storagePath string) *DiskStorage {
	// create path if it doesn't exists
	os.MkdirAll(storagePath, 0700)
	os.MkdirAll(path.Join(storagePath, "notes"), 0700)
	os.MkdirAll(path.Join(storagePath, "blobs"), 0700)
	// create tagIndex file if it doesn't exist
	tagIdxPath := path.Join(storagePath, "tagidx.json")
	if _, err := os.Stat(tagIdxPath); os.IsNotExist(err) {
		// create empty tagIdx and write it
		ti := new(tagIndex)
		ti.Tags = make(map[string][]string)
		ti.Tags["snote/autogenerated"] = make([]string, 2)
		ti.Tags["snote/autogenerated"][0] = "ls"
		ti.Tags["snote/autogenerated"][1] = "lstag"
		f, err := os.OpenFile(tagIdxPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0700)
		defer f.Close()
		if err != nil {
			panic(err)
		}
		json, err := json.Marshal(ti)
		if err != nil {
			panic(err)
		}
		f.Write(json)

	}
	return &DiskStorage{storagePath}
}

func (ds *DiskStorage) LoadNote(id string) (*Note, error) {
	filename := path.Join(ds.path, "notes", id+".json")
	b, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, err
	}
	note := new(Note)
	json.Unmarshal(b, note)
	return note, nil
}

func (ds *DiskStorage) SaveNote(note *Note) error {
	filename := path.Join(ds.path, "notes", note.ID+".json")
	f, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0700)
	defer f.Close()
	if err != nil {
		return err
	}
	json, err := json.Marshal(note)
	if err != nil {
		return err
	}
	f.Write(json)
	return nil
}

func (ds *DiskStorage) DeleteNote(id string) error {
	err := os.Remove(path.Join(ds.path, "notes", id+".json"))
	if err != nil {
		return err
	}
	return nil
}

func (ds *DiskStorage) GetAllNoteIDs() ([]string, error) {
	notesPath := path.Join(ds.path, "notes")
	IDs := make([]string, 0)
	files, err := ioutil.ReadDir(notesPath)
	if err != nil {
		return nil, err
	}

	for _, file := range files {
		if !file.IsDir() && strings.Contains(file.Name(), ".json") {
			ID := strings.Split(file.Name(), ".json")[0]
			IDs = append(IDs, ID)
		}
	}
	return IDs, nil
}

func (ds *DiskStorage) SaveBlob(id string, data bytes.Buffer) error {
	filename := path.Join(ds.path, "blobs", id)

	dst, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0700)
	defer dst.Close()
	if err != nil {
		return err
	}
	dst.Write(data.Bytes())

	return nil
}

func (ds *DiskStorage) LoadBlobPath(id string) (string, error) {
	filename := path.Join(ds.path, "blobs", id)

	// check if the filename exists
	if _, err := os.Stat(filename); err != nil {
		if os.IsNotExist(err) {
			return "", err
		}
	}
	return filename, nil
}

func (ds *DiskStorage) DeleteBlob(id string) error {
	filename := path.Join(ds.path, "blobs", id)
	err := os.Remove(filename)
	if err != nil {
		return err
	}
	return nil
}

func (ds *DiskStorage) GetAllBlobIDs() ([]string, error) {
	blobsPath := path.Join(ds.path, "blobs")
	result := make([]string, 0)

	files, err := ioutil.ReadDir(blobsPath)
	if err != nil {
		return nil, err
	}

	for _, file := range files {
		if !file.IsDir() {
			result = append(result, file.Name())
		}
	}
	return result, nil
}

type tagIndex struct {
	Tags map[string][]string `json:"tags"`
}

func (ds *DiskStorage) SetNoteTags(id string, tags []string) error {
	tagIdxPath := path.Join(ds.path, "tagidx.json")

	// read and unmarshall tagIndex json file
	b, err := ioutil.ReadFile(tagIdxPath)
	if err != nil {
		return err
	}
	ti := new(tagIndex)
	err = json.Unmarshal(b, ti)
	if err != nil {
		return err
	}

	// get all currently stored tags
	currStoredTags := make([]string, 0)
	for tag := range ti.Tags {
		currStoredTags = append(currStoredTags, tag)
	}

	// add id to tags
	for _, targetTag := range tags {
		if util.SliceContainsString(currStoredTags, targetTag) {
			// if targetTag is already in tag index, make sure that
			// it contains note id.
			if util.SliceContainsString(ti.Tags[targetTag], id) {
				// pass
				// TODO(sbrki): make sure there are no duplicates
			} else {
				ti.Tags[targetTag] = append(
					ti.Tags[targetTag], id,
				)
			}

		} else {
			// if targetTag is not already in tag index, add it
			ti.Tags[targetTag] = make([]string, 1)
			ti.Tags[targetTag][0] = id
		}
	}

	// delete id from tag if the note no longer belongs to tag
	for tag := range ti.Tags {
		if !util.SliceContainsString(tags, tag) {
			// make sure that target id is not present
			final := ti.Tags[tag]
			util.SliceRemoveString(&final, id)
			ti.Tags[tag] = final // is this required?
		}

		// delete tag if it has no notes
		if len(ti.Tags[tag]) == 0 {
			delete(ti.Tags, tag)
		}
	}

	// write ti to tagIndex json file
	f, err := os.OpenFile(tagIdxPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0700)
	defer f.Close()
	if err != nil {
		return err
	}
	json, err := json.Marshal(ti)
	if err != nil {
		return err
	}
	f.Write(json)

	return nil
}

func (ds *DiskStorage) GetAllNoteTags() (map[string][]string, error) {
	tagIdxPath := path.Join(ds.path, "tagidx.json")

	// read and unmarshall tagIndex json file
	b, err := ioutil.ReadFile(tagIdxPath)
	if err != nil {
		return nil, err
	}
	ti := new(tagIndex)
	err = json.Unmarshal(b, ti)
	if err != nil {
		return nil, err
	}

	return ti.Tags, nil
}
