package server

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"io"
	"net/http"
	"time"

	"github.com/labstack/echo"
	"github.com/sbrki/snote/internal/storage"
)

func (s *Server) noteGetHandler(c echo.Context) error {
	id := c.Param("note_id")
	var note *storage.Note
	if id == "ls" {
		note = new(storage.Note)
		note.GenerateLs(s.storage)
	} else {
		storedNote, err := s.storage.LoadNote(id)
		if err != nil {
			return echo.NewHTTPError(http.StatusNotFound, "404 Not found")
		}
		note = storedNote
	}
	return c.JSON(http.StatusOK, note)
}

func (s *Server) notePutHandler(c echo.Context) error {
	id := c.Param("note_id")

	// ignore put requests to system autogenerated notes
	if id == "ls" {
		return c.NoContent(http.StatusOK)
	}

	// delete rendered HTML from cache.
	// without deleting the cache on PUT requests the cache
	// get stale.
	s.renderCache.Delete(id)

	updatedNote := new(storage.Note)

	if err := c.Bind(updatedNote); err != nil {
		c.Logger().Error(err)
		return echo.NewHTTPError(http.StatusInternalServerError, "error bining request body json to storage.Note struct (check logs for more info)")
	}

	updatedNote.LastEdit = time.Now()
	updatedNote.Title = updatedNote.ParseTitle()

	err := s.storage.SaveNote(updatedNote)
	if err != nil {
		c.Logger().Error(err)
		return echo.NewHTTPError(http.StatusInternalServerError, "error saving note (check logs for more info)")
	}

	return c.NoContent(http.StatusOK)
}

func (s *Server) noteDeleteHandler(c echo.Context) error {
	id := c.Param("note_id")
	// ignore system autogenerated notes
	if id == "ls" {
		return c.NoContent(http.StatusOK)
	}

	_, err := s.storage.LoadNote(id)
	if err != nil {
		return echo.NewHTTPError(http.StatusNotFound)
	}

	err = s.storage.DeleteNote(id)
	if err != nil {
		c.Logger().Error(err)
		return echo.NewHTTPError(http.StatusInternalServerError)
	}

	return c.NoContent(http.StatusOK)
}

// used by the client to create a new note.
// returns HTTP 409 (Conflict) if a note with the same id already exists.
// returns HTTP 201 (Created)  on a successful creation.
func (s *Server) noteCollectionPostHandler(c echo.Context) error {
	// read the id of the new note that the client suggested
	id := c.FormValue("suggested_id")
	// ignore system autogenerated notes
	if id == "ls" {
		return c.NoContent(http.StatusConflict)
	}

	// check if a note with the provided id exists
	_, err := s.storage.LoadNote(id)
	if err == nil {
		return c.NoContent(http.StatusConflict)
	}

	// create new note
	newNote := new(storage.Note)
	newNote.ID = id
	newNote.Contents = "# " + id
	newNote.LastEdit = time.Now()
	newNote.Tags = make([]string, 0)

	err = s.storage.SaveNote(newNote)
	if err != nil {
		c.Logger().Error(err)
		return c.NoContent(http.StatusInternalServerError)
	}

	return c.NoContent(http.StatusCreated)
}

func (s *Server) blobCollectionPostHandler(c echo.Context) error {
	file, err := c.FormFile("file")
	if err != nil {
		c.Logger().Error(err)
		return c.NoContent(http.StatusInternalServerError)
	}

	src, err := file.Open()
	defer src.Close()
	if err != nil {
		c.Logger().Error(err)
		return c.NoContent(http.StatusInternalServerError)
	}

	// since src is implemented as a multipart stream, calculating its
	// checksum would consume it, so we first copy it to a buffer.
	// probably dangerous for huge files.
	buffer := new(bytes.Buffer)
	if _, err = io.Copy(buffer, src); err != nil {
		c.Logger().Error(err)
		return c.NoContent(http.StatusInternalServerError)
	}

	// calculate checksum of the uploaded file
	hasher := sha256.New()
	hasher.Write(buffer.Bytes())
	checksum := hex.EncodeToString(hasher.Sum(nil))

	// save it to storage
	err = s.storage.SaveBlob(checksum, *buffer)
	if err != nil {
		c.Logger().Error(err)
		return c.NoContent(http.StatusInternalServerError)
	}

	// set the response location header
	c.Response().Header().Set(echo.HeaderLocation, "/api/blob/"+checksum+"/"+file.Filename)
	return c.NoContent(http.StatusCreated)
}

func (s *Server) blobGetHandler(c echo.Context) error {
	id := c.Param("blob_id")
	path, err := s.storage.LoadBlobPath(id)
	if err != nil {
		return c.NoContent(http.StatusNotFound)
	}
	return c.File(path)
}
